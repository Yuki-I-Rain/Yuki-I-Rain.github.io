[{"title":"过渡动画","url":"/2025/12/04/tran-ani/","content":"# 基本用法\n\n- Vue过渡动画的**核心原理依然是采用CSS类来实现的**，只是Vue帮助我们在组件的不同生命周期自动切换不同的CSS类。\n    \n    Vue中默认提供了一个名为**transition的内置组件**，可以用其来包装要展示过渡动画的组件。\n    \n    transition组件的**name属性**用来设置要执行的动画名称，Vue中约定了一系列CSS类名规则来定义各个过渡过程中的组件状态。\n    \n\n```html\n\t\n\t\t<style>\n        .ani-enter-from {\n            width: 0px;\n            height: 0px;\n            background-color: red;\n        }\n        .ani-enter-active {\n            animation: keyframe-in 3s;\n        }\n        .ani-enter-to {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n        }\n        .ani-leave-from {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n        }\n        .ani-leave-active {\n            animation: keyframe-out 3s;\n        }\n        .ani-leave-to {\n            width: 0px;\n            height: 0px;\n            background-color: red;\n        }\n    </style>\n    <div id=\"Application\">  \n        <button @click=\"click\">显示/隐藏</button>\n        <transition name=\"ani\">\n            <div v-if=\"show\">\n            </div>   \n        </transition>\n    </div>\n    <script>\n        const App = Vue.createApp({\n            data(){\n                return {\n                    show:false\n                }\n            },\n            methods:{\n                click(){\n                    this.show = !this.show\n                }\n            }\n        })\n        App.mount(\"#Application\") \n    </script>\n```\n\n当我们为transition组件的name属性设置动画名称之后，当组件被插入页面或被移除时，其会自动寻找以此动画名称开头的CSS类，格式如下：\n\n```html\n x-enter-from\n x-enter-active\n x-enter-to\n x-leave-from\n x-leave-active\n x-leave-to\n\n```\n\n- x-enter-from类在组件即将被插入页面时被添加到组件上，可以理解为组件的**初始状态**，元素被插入页面后此类会马上被移除。\n\n    v-enter-active类在组件的整个插入过渡动画中都会被添加，直到组件的过渡动画结束后才会被移除。可以在这个类中**定义组件过渡动画的时长、方式、延迟等。**\n\n    v-enter-to类在组件被插入页面后立即被添加，此时x-enter-from类会被移除，可以理解为组件过渡的**最终状态。**\n\n    后面3个与前面3个相对应，如x-leave-from即为**移除组件时过渡动画的起始状态。**\n\n- 运行程序，注意到动画执行完成后，组件的样式并不会保留，且并没有预期的过渡效果。下面将会演示更常见的做法：在组件本身绑定一个最终状态的样式类\n\n---\n\n# 推荐用法\n\n- transition内，添加class类\n\n```html\n<transition name=\"ani\"> \n\t<div v-if=\"show\" class=\"demo\"> \n\t</div> \n</transition> \n```\n\n- CSS代码如下\n\n```css\n.demo {\n\twidth: 100px;\n\tlength: 100px;\n\tbackground-colour: blue;\n}\n```\n\n- 关键帧动画的定义\n\n```css\n        @keyframes keyframe-in {\n            from {\n                width: 0px;\n                height: 0px;\n                background-color: red;\n            }\n            to {\n                width: 100px;\n                height: 100px;\n                background-color: red;\n            }\n        }\n        @keyframes keyframe-out {\n            from {\n                width: 100px;\n                height: 100px;\n                background-color: blue;\n            }\n            to {\n                width: 0px;\n                height: 0px;\n                background-color: red;\n            }\n        }\n```\n\n关键帧动画的定义使得animation属性生效，并使得过渡效果更加生动\n\n- 下面为完整代码\n\n```css\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n    <title>Vue过渡动画</title>\n</head>\n<body>\n    <style>\n        @keyframes keyframe-in {\n            from {\n                width: 0px;\n                height: 0px;\n                background-color: red;\n            }\n            to {\n                width: 100px;\n                height: 100px;\n                background-color: red;\n            }\n        }\n        @keyframes keyframe-out {\n            from {\n                width: 100px;\n                height: 100px;\n                background-color: blue;\n            }\n            to {\n                width: 0px;\n                height: 0px;\n                background-color: red;\n            }\n        }       \n        .demo {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n        }\n        .ani-enter-from {\n            width: 0px;\n            height: 0px;\n            background-color: red;\n        }\n        .ani-enter-active {\n            animation: keyframe-in 3s;\n        }\n        .ani-enter-to {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n        }\n        .ani-leave-from {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n        }\n        .ani-leave-active {\n            animation: keyframe-out 3s;\n        }\n        .ani-leave-to {\n            width: 0px;\n            height: 0px;\n            background-color: red;\n        }\n    </style>\n    <div id=\"Application\">  \n        <button @click=\"click\">显示/隐藏</button>\n        <transition name=\"ani\">\n            <div v-if=\"show\" class=\"demo\">\n            </div>   \n        </transition>\n    </div>\n    <script>\n        const App = Vue.createApp({\n            data(){\n                return {\n                    show:false\n                }\n            },\n            methods:{\n                click(){\n                    this.show = !this.show\n                }\n            }\n        })\n        App.mount(\"#Application\") \n    </script>\n</body>\n</html>\n```\n\n运行效果\n\n![](https://img.xwyue.com/i/2025/12/04/69310e4c61ebd.gif)\n\n可以看到，从0x0到100x100的红色，显示动画结束后立即变为蓝色，这是因为关键帧动画与Vue过渡类定义的样式不一致（为了演示），前者优先级高。\n\n**最佳实践**是**保持关键帧和过渡类样式的一致性**，或者根据需要明确选择使用哪种方式来控制过渡效果。","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"Teleport的使用","url":"/2025/11/20/teleport/","content":"**Teleport**可以把组件的某一部分 DOM 渲染到 Vue 组件树之外的任意指定位置，而逻辑（状态、事件）仍保留在原组件内部。\n\n这个特性非常适用于**模态框、弹出框**等需要在页面特定位置显示的组件。\n\n```html\n\n<div id=\"Application\">\n\t<div style=\"position: absolute; width: 50px;\">\n    <my-alert></my-alert>\n  </div>\n</div>\n<script>\nconst App = Vue.createApp({})\nApp.component(\"my-alert\", {\n  template: `\n    <div>\n      <button @click=\"show = true\">弹出弹窗</button>\n    </div>\n    <teleport to=\"body\">\n      <div v-if=\"show\" style=\"\n        text-align: center;\n        padding: 20px;\n        position: absolute;\n        top: 30%;\n        left: 30%;\n        width: 40%;\n        border: black solid 2px;\n        background-color: white;\n      \">\n        <h3>弹窗</h3>\n        <button @click=\"show = false\">隐藏弹窗</button>\n      </div>\n    </teleport>\n  `,\n  data() {\n    return {\n      show: false\n    };\n  }\n});\nApp.mount('#Application')\n</script>\n\n```\n\n如上所示\n\n- 弹窗覆盖全屏，不受父级 `position: absolute; width: 50px;` 的限制；\n- `show` 状态仍由 `<my-alert>` 组件自身管理，不需要额外的全局状态或事件总线；","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"Mixin技术","url":"/2025/11/17/mixin/","content":"# 基本用法\n\n- 通过Mixin技术，组件的复用性可以得到进一步的提高：\n\n```html\n<body>\n  <div id=\"Application\">\n    <my-com1 title=\"组件1\"></my-com1>\n    <my-com2 title=\"组件2\"></my-com2>\n    <my-com3 title=\"组件3\"></my-com3>\n  </div>\n\n  <script>\n    const App = Vue.createApp({});\n\n    const com1 = {\n      props: ['title'],\n      template: `\n        <div style=\"border:red solid 2px;\">\n          {{ title }}\n        </div>\n      `\n    };\n\n    const com2 = {\n      props: ['title'],\n      template: `\n        <div style=\"border:blue solid 2px;\">\n          {{ title }}\n        </div>\n      `\n    };\n\n    const com3 = {\n      props: ['title'],\n      template: `\n        <div style=\"border:green solid 2px;\">\n          {{ title }}\n        </div>\n      `\n    };\n\n    // 注册组件\n    App.component(\"my-com1\", com1);\n    App.component(\"my-com2\", com2);\n    App.component(\"my-com3\", com3);\n\n    // 挂载应用\n    App.mount(\"#Application\");\n  </script>\n</body>\n```\n\n- 我们可以定义一个混入对象(Mixin)，混入对象中可以包含任意的组件定义选项，当此对象被混入组件时，组件会将混入对象中提供的选项引入当前组件内部。\n\n```html\n<body>\n  <div id=\"Application\">\n    <my-com1 title=\"组件1\"></my-com1>\n    <my-com2 title=\"组件2\"></my-com2>\n    <my-com3 title=\"组件3\"></my-com3>\n  </div>\n\n  <script>\n    const App = Vue.createApp({});\n\n    const myMixin = {\n        props: ['title']\n    }\n\n    const com1 = {\n      mixins: [myMixin],\n      template: `\n        <div style=\"border:red solid 2px;\">\n          {{ title }}\n        </div>\n      `\n    };\n\n    const com2 = {\n      mixins: [myMixin],    \n      template: `\n        <div style=\"border:blue solid 2px;\">\n          {{ title }}\n        </div>\n      `\n    };\n\n    const com3 = {\n      mixins: [myMixin],\n      template: `\n        <div style=\"border:green solid 2px;\">\n          {{ title }}\n        </div>\n      `\n    };\n\n    // 注册组件\n    App.component(\"my-com1\", com1);\n    App.component(\"my-com2\", com2);\n    App.component(\"my-com3\", com3);\n\n    // 挂载应用\n    App.mount(\"#Application\");\n  </script>\n</body>\n```\n\n# Mixin选项的合并\n\n当混入对象与组件中定义了相同的选项时，Vue可以非常智能地对这些选项进行合并。\n\n- 不冲突的配置将完整合并：\n    \n    混入对象中定义了组件的属性数据，包含a、b和c共3个属性，组件本身定义了d属性，最终组件在使用时，其内部的属性会包含a、b、c和d。\n    \n\n```jsx\nconst myMixin = {\n  data() {\n    return {\n      a: \"a\",\n      b: \"b\",\n      c: \"c\"\n    }\n  }\n}\n\nconst com = {\n  mixins: [myMixin],\n  data() {\n    return {\n      d: \"d\"\n    }\n  },\n  // 组件被创建后会调用,用来测试混入的数据情况\n  created() {\n    // a,b,c,d都存在\n    console.log(this.$data)\n  }\n}\n```\n\n- 如果属性的定义有冲突，则以组件内部定义的为准，例如:\n\n```jsx\nconst myMixin = {\n  props: ['title'],\n  data() {\n    return {\n      a: 'a',\n      b: 'b',\n      c: 'c'\n    }\n  }\n}\n\nconst com = {\n  mixins: [myMixin],\n  data() {\n    return {\n      c: 'C' // 覆盖 mixin 中的 c\n    }\n  },\n  created() {\n    // 组件创建后执行，验证数据合并结果\n    console.log(this.$data); // 输出：{ a: 'a', b: 'b', c: 'C' }\n  }\n}\n```\n\n# 全局Mixin\n\n- 直接对应用实例进行Mixin设置即可：\n\n```jsx\nconst App = Vue.createApp({})\nApp.mixin({\n\tmounted(){\n\t\tconsole.log(\"Mixin对象mounted\")\n\t}\n})\n```","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"数据注入","url":"/2025/11/15/data-injection/","content":"所谓数据注入，**是指父组件可以向其所有子组件提供数据**，不论在层级结构上此子组件的层级有多深。\n\n实现数据注入需要使用组件的`provide`与`inject`两个配置项，提供数据的**父组件**需要设置`provide`配置项来提供数据，**子组件**需要设置`inject`配置项来获取数据。\n\n```html\n<body>\n    <div id=\"Application\">\n        <my-list :count=\"5\">\n        </my-list>\n    </div>\n    <script>\n        const App = Vue.createApp({})\n        const listCom = {\n            props:{   \n                count: Number\n            },\n            provide(){\n                return {\n                    listCount:this.count\n                }\n            },\n            template:`\n                <div style=\"border:red solid 10px;\">\n                    <my-item v-for=\"i in this.count\" :index=\"i\"></my-item>\n                </div>\n            `\n        }\n        const itemCom = {\n            props: {\n                index:Number\n            },\n            template:`\n                <div style=\"border:blue solid 10px;\"><my-label :index=\"this.index\"></my-label></div>\n            `\n        }\n        const labelCom = {\n            props: {\n                index:Number\n            },\n            inject:['listCount'],\n            template:`\n                <div>{{index}}/{{this.listCount}}</div>\n            `\n        }\n        App.component(\"my-list\", listCom)\n        App.component(\"my-item\", itemCom)\n        App.component(\"my-label\", labelCom)\n        App.mount(\"#Application\") \n    </script>\n</body>\n```","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"组件的高级配置(应用的全局配置选项)","url":"/2025/10/20/global-configuration/","content":"当调用Vue.createApp方法后，会创建一个Vue应用实例，对于此应用实例，**其内部封装了一个config对象，我们可以通过这个对象的一些全局选项来对其进行配置**。常用的配置项有**异常与警告捕获配置**和**全局属性配置**。\n\n- 异常和警告，使用自定义的函数来对抛出的异常和警告进行处理：\n    \n    ```jsx\n    const App = Vue.createApp({})\n    \n    App.config.errorHandler = (err, vm, info) => {\n        // 捕获运行中产生的异常\n        // err参数是错误对象,info为具体的错误信息\n    }\n    \n    App.config.warnHandler = (msg, vm, trace) => {\n        // 捕获运行中产生的警告\n        // msg是警告信息,trace是组件的关系回溯\n    }\n    ```\n    \n- 通过globalProperties全局属性对象进行配置：\n    \n    ```jsx\n    const App = Vue.createApp({})\n    \n    // 配置全局数据\n    App.config.globalProperties = {\n        version: \"1.0.0\"\n    }\n    \n    const sub = {\n        mounted() {\n            // 在任意组件的任意地方都可以通过this直接访问全局数据\n            console.log(this.version)\n        }\n    }\n    ```","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"自定义组件的插槽","url":"/2025/10/16/slot/","content":"插槽是指HTML起始标签与结束标签中间的部分，通常在使用div标签时，其内部的插槽位置既可以放置要显示的文案，又可以嵌套放置其他标签，例如：\n\n```html\n<div>文案部分</div>\n<div>\n\t<button>按钮</button>\n</div>\n```\n\n插槽的核心作用是将组件内部的元素抽离到外部进行实现，在进行自定义组件的设计时，良好的插槽逻辑可以使组件的使用更加灵活。\n\n---\n\n# 基本用法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vue组件插槽</title>\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n</head>\n<body>\n    <div id=\"Application\">\n        <my-container>插槽内部</my-container>\n    </div>\n    <script>\n        const App = Vue.createApp({ })\n        const containerComponent = {\n            template: `<div style=\"border-style:solid;border-color:red; border-width:10px\">\n                <slot>默认内容</slot>\n            </div>`\n        }\n        App.component(\"my-container\", containerComponent)\n        App.mount(\"#Application\")\n    </script>\n</body>\n</html>\n```\n\n- 使用`slot`标签来指定插槽的位置\n- 可以为插槽添加默认内容（组件在使用时设置了插槽的内容，默认内容就不会被渲染）\n\n---\n\n# (多)具名插槽的用法\n\n- 若要为插槽设置名称，则可以使用name属性来为其设置名称\n- 需要注意的是，在使用此组件时，**要使用template标签来包装插槽内容，**对于template标签，通过#（等价于v-slot）来指定与其对应的插槽位置。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vue组件插槽</title>\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n</head>\n<body>\n    <div id=\"Application\">\n        <my-container2>\n            <template #header>\n                <h1>这里是头部元素</h1>\n            </template>\n        \n            <template #main>\n                <p>内容部分</p>\n                <p>内容部分</p>\n            </template>\n        \n            <template #footer>\n                <p>这里是尾部元素</p>\n            </template>\n        </my-container2>\n    </div>\n    <script>\n        const App = Vue.createApp({\n        })\n        const container2Component = {\n            template:`<div>\n                    <slot name=\"header\"></slot>\n                    <hr/>\n                    <slot name=\"main\"></slot>\n                    <hr/>\n                    <slot name=\"footer\"></slot>\n                </div>`\n        }\n        App.component(\"my-container2\", container2Component)\n        App.mount(\"#Application\") \n    </script>\n</body>\n</html>\n```","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"组件中数据与事件的传递","url":"/2025/09/29/transmit/","content":"\n# 基本用法\n\n- 当我们创建好了Vue应用实例后，使用mount方法可以将其绑定到指定的HTML元素上。应用实例可以使用`component`方法来定义组件，定义好组件后，可以直接在HTML文档中进行使用。\n\n- 自定义警告提示框：\n\n```jsx\n<script>\n  const App = Vue.createApp({})\n  \n  const alertComponent = {\n    data() {\n      return {\n        msg: \"警告框提示\",\n        count: 0\n      }\n    },\n    methods: {\n      click() {\n        alert(this.msg + this.count++)\n      }\n    },\n    template: `<div><button @click=\"click\">按钮</button></div>`\n  }\n  \n  App.component(\"my-alert\", alertComponent)\n  App.mount(\"#Application\")\n</script>\n```\n\n需要使用自定义的组件时，只需使用组件名**标签**即可：\n\n```html\n<div id=\"Application\">\n    <my-alert></my-alert>\n    <my-alert></my-alert>\n</div>\n```\n\n# 处理组件事件\n\n- 用emit传递事件\n\n```html\n<!DOCTYPE html> \n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vue组件</title>\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n</head>\n<body>\n    <div id=\"Application\">\n        <my-alert @myclick=\"appfunc\" title=\"btn1\"></my-alert>\n        <my-alert title=\"btn2\"></my-alert>\n    </div>\n    <script>\n        const App = Vue.createApp({\n            methods:{\n                appfunc(){\n                    console.log(\"btn clicked\")\n                }\n            }\n        })\n        const alertComponent = {\n            props:[\"title\"],\n            template:`<div><button @click=\"$emit('myclick')\">{{title}}</button></div>`\n        }\n        App.component(\"my-alert\",alertComponent)\n        App.mount(\"#Application\")\n    </script>\n</body>\n</html>\n```\n\n- 可以同时传递一些参数\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vue组件</title>\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n</head>\n<body>\n    <div id=\"Application\">\n        <my-alert @myclick=\"appfunc\" title=\"btn1\"></my-alert>\n        <my-alert @myclick=\"appfunc\" title=\"btn2\"></my-alert>\n    </div>\n    <script>\n        const App = Vue.createApp({\n            methods:{\n                appfunc(param){\n                    console.log(param+\" clicked\")\n                }\n            }\n        })\n        const alertComponent = {\n            props:[\"title\"],\n            template:`<div><button @click=\"$emit('myclick',title)\">{{title}}</button></div>`\n        }\n        App.component(\"my-alert\",alertComponent)\n        App.mount(\"#Application\")\n    </script>\n</body>\n</html>\n```\n\n- 若在传递事件之前，子组件还有一些内部的逻辑需要处理，也可以在子组件中包装一个方法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vue组件</title>\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n</head>\n<body>\n    <div id=\"Application\">\n        <my-alert @myclick=\"appfunc\" title=\"btn1\"></my-alert>\n        <my-alert @myclick=\"appfunc\" title=\"btn2\"></my-alert>\n    </div>\n    <script>\n        const App = Vue.createApp({\n            methods:{\n                appfunc(param){\n                    console.log(param+\" clicked\")\n                }\n            }\n        })\n        const alertComponent = {\n            props:[\"title\"],\n            methods:{\n                click1(){\n                    console.log(\"inside\")\n                    this.$emit('myclick',this.title)\n                }\n            },\n            template:`<div><button @click=\"click1\">{{title}}</button></div>`\n        }\n        App.component(\"my-alert\",alertComponent)\n        App.mount(\"#Application\")\n    </script>\n</body>\n</html>\n```\n\n# 在组件上使用v-model指令\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vue组件</title>\n    <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n</head>\n<body>\n    <div id=\"Application\">\n        <my-input v-model=\"inputText\"></my-input>\n        <div>{{inputText}}</div>\n        <button @click=\"inputText = ''\">清空</button>\n    </div>\n    <script>\n        const App = Vue.createApp({\n            data() {\n                return {\n                    inputText: \"\"\n                }\n            }\n        })\n        const inputComponent = {\n            props: [\"modelValue\"],\n            methods: {\n                action(event) {\n                    this.$emit('update:modelValue', event.target.value)\n                }\n            },\n            template: '<div><span>输入框:</span><input :value=\"modelValue\" @input=\"action\"></div>'\n        }\n        App.component(\"my-input\", inputComponent)\n        App.mount(\"#Application\")\n    </script>\n</body>\n</html>\n```\n\n其实，所有支持v-model指令的组件中默认都会提供一个名为modelValue的属性，而**组件内部的内容变化后向外传递的事件为`update:modelValue`**，并且在事件传递时会将组件内容作为参数进行传递。因此，我们要让自定义组件能够使用v-model指令，只需要按照正确的规范来定义组件即可。\n","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"TRAE meetup @Guangzhou","url":"/2025/09/22/TRAE-meetup/","content":"\n# 开场\n- 1.40 p.m.到达会场，领取物资，签名，并找位置坐下后，暖场活动就开始了\n![2.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab516310d.jpg)\n![1.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab4635a6a.jpg)\n\n- 暖场活动大概持续20分钟，内容是每个人给自己的职业想3个标签（不剧透），然后让一位在台下的观众猜一下，猜对了各奖励一个抱枕\n- 2.00 p.m. 活动正式开始，活动主线为4场讲座+茶歇\n\n# 如何与AI（高潜实习生）协作\n\n![3.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab4986b07.jpg)\n![4.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab4f0f8e0.jpg)\n\n- 协作方法论：\n    明确任务边界，把模糊的需求转化为清晰的PRD\n    提供结构化的输入，以及必要的上下文信息\n    建立质量兜底制度，随时准备好接手补位\n\n---\n# Context Engineering(上下文工程)\n**高质量的输出，源于高质量的上下文输入**\n\n![5.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab452c33c.jpg)\n![6.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab3cd44cb.jpg)\n![7.jpg](https://img.xwyue.com/i/2025/09/22/68d0ab4125d27.jpg)\n\n# 茶歇\n\n![10.jpg](https://img.xwyue.com/i/2025/09/23/68d173fb6ae60.jpg)\n\n# 合照\n\n![11.jpg](https://img.xwyue.com/i/2025/09/23/68d173fe29d3e.jpg)\n\n","tags":["AI","TRAE"],"categories":["Life"]},{"title":"Hello World","url":"/2025/09/14/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["Hexo"],"categories":["Instruction"]},{"title":"Vue常用指令","url":"/2025/09/04/directives/","content":"# v-model\n\n## 基本用法\n\n在表单上使用，用于双向绑定\n\n![image.png](https://img.xwyue.com/i/2025/09/29/68da7bea0183c.png)\n\n### 实用修饰符\n\n- lzay修饰符\n    \n    ```html\n    <input v-model.lazy=\"textField\"/>\n     <p>文本输入框内容:{{textField}}</p>\n    ```\n    \n    只有当用户完成输入，即输入框失去焦点后，段落中才会同步到输入框中最终的文本数据。\n    \n- trim修饰符\n    \n    ```html\n    <input v-model.trim=\"textField\"/>\n     <p>文本输入框内容:{{textField}}</p>\n    ```\n    \n    将绑定的文本数据的首尾空格去掉。\n    \n\n---\n\n# v-on(@)\n\n## 基本用法\n\n![image 1.png](https://img.xwyue.com/i/2025/09/29/68da7be95eac8.png)\n\n为html标签绑定事件\n\n### 事件类型\n\n|  |  |  |\n| --- | --- | --- |\n| 事件 | 意义 | 可用的元素 |\n| click | 单击事件，当组件被单击时触发 | 大部分 HTML 元素 |\n| dblclick | 双击事件，当组件被双击时触发 | 大部分 HTML 元素 |\n| focus | 获取焦点事件，例如输入框开启编辑模式时触发 | input、select、textarea 等 |\n| blur | 失去焦点事件，例如输入框结束编辑模式时触发 | input、select、textarea 等 |\n| change | 元素内容改变事件，输入框结束输入后，如果内容有变化，会触发此事件 | input、select、textarea 等 |\n| select | 元素内容选中事件，输入框中的文本被选中时会触发此事件 | input、select、textarea 等 |\n| mousedown | 鼠标按键被按下事件 | 大部分 HTML 元素 |\n| mouseup | 鼠标按键抬起事件 | 大部分 HTML 元素 |\n| mousemove | 鼠标在组件内移动事件 | 大部分 HTML 元素 |\n| mouseout | 鼠标移出组件时触发 | 大部分 HTML 元素 |\n| mouseover | 鼠标移入组件时触发 | 大部分 HTML 元素 |\n| Keypdown | 键盘按键被按下 | HTML 中所有表单元素 |\n| keyup | 键盘按键被抬起 | HTML 中所有表单元素 |\n\n### 事件修饰符\n\n- capture修饰符\n    \n    可以将监听事件的实际设置为捕获阶段，示例如下：\n    \n    ```html\n           <div @click.capture=\"click1\" style=\"border:solid red\">\n                外层\n               <div @click.capture=\"click2\" style=\"border:solid red\">\n                   中层\n                   <div @click.capture=\"click3\" style=\"border:solid red\">\n                       点击\n                   </div>\n               </div>\n           </div>\n          \n    ```\n    \n    点击最内层元素，控制台输出：\n    \n    ```html\n    外层\n    中层\n    内层\n    ```\n    \n- stop修饰符\n    \n    stop修饰符可以阻止事件的传递，例如：\n    \n    ```html\n           <div @click.stop=\"click1\" style=\"border:solid red\">\n                外层\n               <div @click.stop=\"click2\" style=\"border:solid red\">\n                   中层\n                   <div @click.stop=\"click3\" style=\"border:solid red\">\n                       点击\n                   </div>\n               </div>\n           </div>\n    ```\n    \n    点击最内层元素，控制台：\n    \n    ```html\n    内层\n    ```\n    \n- 其他修饰符\n    \n    \n    |  |  |\n    | --- | --- |\n    | 事件修饰符 | 作 用 |\n    | stop | 阻止事件传递 |\n    | capture | 监听捕获场景的事件 |\n    | once | 只触发一次事件 |\n    | exact | 只有精确满足按键的条件才会触发事件（按键组合） |\n    | self | 当事件对象的 target 属性是当前组件时才触发事件 |\n    | Prevent | 禁止默认的事件 |\n    | passive | 不禁止默认事件 |\n    | 其他鼠标按键修饰符 |  |\n    | left | 鼠标左键（click.left） |\n    | right | 鼠标右键 |\n    | middle | 鼠标中键 |\n- 系统按键修饰符\n    \n    Vue中还提供了一些特殊的系统按键修饰符，这些修饰符是配合其他键盘按键或鼠标按键进行使用的，主要有如下4种：\n    \n    **ctrl, shift, alt, meta(windows/command)**\n    \n    示例：\n    \n    ```html\n    \n    <div @mousedown. ctrl=\"mousedown\">鼠标按下</div>\n    <--! 上面代码的作用是用户按下Ctrl键的同时,再按下鼠标按键才会触发绑定的事件函数。-->\n    ```\n    \n    ```html\n    <input @keyup.alt.enter=\"keyup\"></input> \n    <--! 上面代码的作用是用户按下Alt键的同时,再按回车键才会触发绑定的事件函数。 -->\n    ```\n    \n\n---\n\n# v-bind(:)\n\n## 基本用法\n\n为html标签绑定属性值（在html标签内，不能使用插值表达式）\n\n![image 2.png](https://img.xwyue.com/i/2025/09/29/68da7be6df9dd.png)\n\n---","tags":["Vue3","Frontend"],"categories":["Notes"]},{"title":"Data type","url":"/2025/06/23/type/","content":"![data_type](/img/type.png)","tags":["SQL"],"categories":["Notes"]},{"title":"Distinguish having and where","url":"/2025/06/16/having-where/","content":"\n|  | WHERE | HAVING |\n| --- | --- | --- |\n| 执行时机 | 分组前过滤 | 分组后过滤 |\n| 使用对象 | 原始表中的列 | 分组结果或聚合函数计算结果 |\n| 性能 | 通常更高效 | 通常效率较低 |\n\n```sql\nSELECT department, AVG(salary) \nFROM employees \nGROUP BY department \nHAVING AVG(salary) > 5000;  -- 不能用WHERE过滤聚合结果\n```\n\n```sql\nSELECT product_id, COUNT(*) as order_count\nFROM orders\nGROUP BY product_id\nHAVING order_count > 10;  -- 过滤分组后的计数结果\n```\n\n```sql\nSELECT customer_id, SUM(amount) as total_spent\nFROM transactions\nGROUP BY customer_id\nHAVING total_spent > 1000;  -- WHERE不能使用别名\n```\n\n---\n\n# 使用建议\n\n1. **优先使用WHERE**：能在WHERE中完成的条件就不要用HAVING，减少分组处理的数据量\n2. **必须时才用HAVING**：只有当过滤条件依赖于分组结果或聚合函数时才使用HAVING\n3. **组合使用**：经常WHERE和HAVING一起使用，先用WHERE初步筛选，再用HAVING对分组结果过滤","tags":["SQL"],"categories":["Notes"]},{"title":"Regular Expression","url":"/2025/06/15/regexp/","content":"\n# 一般形式\n\n```sql\nWHERE example_column REGEXP '这里写正则表达式内容'\n```\n\n**注意**：\n\n- 要加引号\n- 默认情况**不**区分大小写\n    \n    若要区分，则使用\n    \n\n```sql\nREGEXP BINARY\n```\n\n---\n\n# 基本用法\n\n^ 表示字符串开始\n\ne.g.  ^e表示以e开始\n\n**注意:若^在[]里面,则表示取补集**\n\ne.g.  [^a]表示除了a以外的所有字母\n\n---\n\n$表示字符串结束\n\ne.g.x$表示以x结束\n\n---\n\n[]表示 character set，结合-使用表示范围，\n\ne.g: [1-9]表示1,2,3,4,5....8,9组成的集合\n\n[cde]表示c,d,e中的一个字符\n\n---\n\n{}为数量符,匹配前一个字符的数量\n\ne.g: [0-9]{2}表示2个0-9中的任意字符\n\ne{3,5}表示至少3个,至多5个e\n\n---\n\n？为数量符，匹配前一个字符1次或0次 \n\ne.g.  -?表示搜寻'0个或者1个字符 \"-\" \n\n---\n\n+为数量符,匹配前一个字符至少1次\n\ne.g.  3[a-z]+4表示3与4之间有至少一个字母\n\n---\n\n*为数量符,匹配前一个字符0次或多次(包括1次)\n\n.等价于占位符,匹配(除了换行符外的)单个字符\n\n|表示逻辑运算符”或”\n\n---\n\n# 例题\n\n[电话号码格式校验_牛客题霸_牛客网](https://www.nowcoder.com/share/jump/1510625831749995207287)\n\n[【鲸析】SQL面试大实话之【正则表达式 REGEXP 实战解析】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UB4y1L7gz)\n\n---\n\n# 总结\n\n![regular_expression_summary](/img/image.png)","tags":["SQL"],"categories":["Notes"]},{"title":"Union","url":"/2025/06/05/union/","content":"\n# Basic Sentence\n\n```sql\nSELECT column_name(s) FROM table_name1\nUNION\nSELECT column_name(s) FROM table_name2\n```\n\n- The SELECT statements within a UNION must have the **same number of columns**. Columns must also have **similar data types**. Meanwhile, the **order of the columns in each SELECT statement must be the same**.\n- SELECT will **automatic deduplication**, while SELECT ALL will not.\n\n---\n\n## UNION\n\n<a id=\"section2\"></a>\n**Tables:**\n\nemployees:\n\n| emp_id | name | dpt_id |\n| --- | --- | --- |\n| 1 | apple | 101 |\n| 2 | boy | 102 |\n| 3 | cat | 101 |\n| 4 | dog | 103 |\n\nformer_employees:\n\n| emp_id | name | dpt_id |\n| --- | --- | --- |\n| 5 | egg | 102 |\n| 2 | boy | 102 |\n\n```sql\nSELECT name, dpt_id FROM employees\nUNION\nSELECT name, dpt_id FROM former_employees;\n```\n\nresult:\n\n| name | dpt_id |  |\n| --- | --- | --- |\n| apple | 101 |  |\n| boy | 102 | **automatic deduplication** |\n| cat | 101 |  |\n| dog | 103 |  |\n| egg | 102 |  |\n\n---\n\n## UNION ALL\n\n[Tables](#section2): \n\n```sql\nSELECT name, dpt_id FROM employees\nUNION ALL\nSELECT name, dpt_id FROM former_employees;\n```\n\n**result:**\n\n| name | dpt_id |  |\n| --- | --- | --- |\n| apple | 101 |  |\n| boy | 102 | first record |\n| cat | 101 |  |\n| dog | 103 |  |\n| egg | 102 |  |\n| boy | 102 | from former_employees |v","tags":["SQL"],"categories":["Notes"]},{"title":"Join(two tables)","url":"/2025/06/04/join/","content":"\n# Basic sentence\n\n```sql\nSELECT columns\nFROM table1\n() JOIN table2\nON table1.column_name=table2.column_name; \n```\n\n## INNER JOIN\n\nINNER JOIN equals to JOIN,\n\nExplicit form \n\n```sql\nINNER JOIN\n```\n\nImplicit form\n\n```sql\nJOIN\n```\n<a id=\"section1\"></a>\n### Tables :\n\nPerson :\n\n| personID | lastName | firstName |\n| --- | --- | --- |\n| 1 | Wang | Allen |\n| 2 | Alice | Bob |\n\nAddress:\n\n| addressID | personID | city | state |\n| --- | --- | --- | --- |\n| 1 | 2 | New York City | New York |\n| 2 | 3 | Leetcode | California |\n\n```sql\nSELECT Person.firstName, Address.city\nFROM Person\nINNER JOIN Address\nON Person.personID = Address.personID;\n```\n\n**result:**\n\n| firstName | city |\n| --- | --- |\n| Bob | New York City |\n\n---\n\n## LEFT JOIN\n\n### [Tables :](#section1)\n\n```sql\nSELECT Person.firstName, Address.city\nFROM Person LEFT JOIN Address # Write in one line is more intuitive\nON Person.personID = Address.personID;\n```\n\n**result:**\n\n| firstName | city |\n| --- | --- |\n| Bob | New York City |\n| Allen | NULL |\n\n---\n\n## RIGHT JOIN\n\n### [Tables :](#section1)\n\n```sql\nSELECT Person.firstName, Address.city\nFROM Person RIGHT JOIN Address # Write in one line is more intuitive\nON Person.personID = Address.personID;\n```\n\n**result:**\n\n| firstName | city |\n| --- | --- |\n| Bob | New York City |\n| NULL | Leetcode |\n\n---\n\n## FULL JOIN\n\n### [Tables :](#section1)\n\n```sql\nSELECT Person.firstName, Address.city\nFROM Person \nFULL JOIN Address\nON Person.personID = Address.personID;\n```\n\n**result:**\n\n| firstName | city |\n| --- | --- |\n| Bob | New York City |\n| Allen | NULL |\n| NULL | Leetcode |\n\n---\n\n# Summary\n\n![join_summary](/img/屏幕截图_2025-06-05_104939.png)\n\n","tags":["SQL"],"categories":["Notes"]}]