<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TRAE meetup @Guangzhou</title>
    <url>/2025/09/22/TRAE-meetup/</url>
    <content><![CDATA[开场
1.40 p.m.到达会场，领取物资，签名，并找位置坐下后，暖场活动就开始了

暖场活动大概持续20分钟，内容是每个人给自己的职业想3个标签（不剧透），然后让一位在台下的观众猜一下，猜对了各奖励一个抱枕

2.00 p.m. 活动正式开始，活动主线为4场讲座+茶歇


如何与AI（高潜实习生）协作

协作方法论：  明确任务边界，把模糊的需求转化为清晰的PRD  提供结构化的输入，以及必要的上下文信息  建立质量兜底制度，随时准备好接手补位


Context Engineering(上下文工程)高质量的输出，源于高质量的上下文输入

茶歇
合照
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>TRAE</tag>
      </tags>
  </entry>
  <entry>
    <title>数据注入</title>
    <url>/2025/11/15/data-injection/</url>
    <content><![CDATA[所谓数据注入，是指父组件可以向其所有子组件提供数据，不论在层级结构上此子组件的层级有多深。
实现数据注入需要使用组件的provide与inject两个配置项，提供数据的父组件需要设置provide配置项来提供数据，子组件需要设置inject配置项来获取数据。
&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-list :count=&quot;5&quot;&gt;        &lt;/my-list&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123;&#125;)        const listCom = &#123;            props:&#123;                   count: Number            &#125;,            provide()&#123;                return &#123;                    listCount:this.count                &#125;            &#125;,            template:`                &lt;div style=&quot;border:red solid 10px;&quot;&gt;                    &lt;my-item v-for=&quot;i in this.count&quot; :index=&quot;i&quot;&gt;&lt;/my-item&gt;                &lt;/div&gt;            `        &#125;        const itemCom = &#123;            props: &#123;                index:Number            &#125;,            template:`                &lt;div style=&quot;border:blue solid 10px;&quot;&gt;&lt;my-label :index=&quot;this.index&quot;&gt;&lt;/my-label&gt;&lt;/div&gt;            `        &#125;        const labelCom = &#123;            props: &#123;                index:Number            &#125;,            inject:[&#x27;listCount&#x27;],            template:`                &lt;div&gt;&#123;&#123;index&#125;&#125;/&#123;&#123;this.listCount&#125;&#125;&lt;/div&gt;            `        &#125;        App.component(&quot;my-list&quot;, listCom)        App.component(&quot;my-item&quot;, itemCom)        App.component(&quot;my-label&quot;, labelCom)        App.mount(&quot;#Application&quot;)     &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue常用指令</title>
    <url>/2025/09/04/directives/</url>
    <content><![CDATA[v-model基本用法在表单上使用，用于双向绑定

实用修饰符
lzay修饰符
  &lt;input v-model.lazy=&quot;textField&quot;/&gt; &lt;p&gt;文本输入框内容:&#123;&#123;textField&#125;&#125;&lt;/p&gt;
  只有当用户完成输入，即输入框失去焦点后，段落中才会同步到输入框中最终的文本数据。

trim修饰符
  &lt;input v-model.trim=&quot;textField&quot;/&gt; &lt;p&gt;文本输入框内容:&#123;&#123;textField&#125;&#125;&lt;/p&gt;
  将绑定的文本数据的首尾空格去掉。



v-on(@)基本用法
为html标签绑定事件
事件类型








事件
意义
可用的元素


click
单击事件，当组件被单击时触发
大部分 HTML 元素


dblclick
双击事件，当组件被双击时触发
大部分 HTML 元素


focus
获取焦点事件，例如输入框开启编辑模式时触发
input、select、textarea 等


blur
失去焦点事件，例如输入框结束编辑模式时触发
input、select、textarea 等


change
元素内容改变事件，输入框结束输入后，如果内容有变化，会触发此事件
input、select、textarea 等


select
元素内容选中事件，输入框中的文本被选中时会触发此事件
input、select、textarea 等


mousedown
鼠标按键被按下事件
大部分 HTML 元素


mouseup
鼠标按键抬起事件
大部分 HTML 元素


mousemove
鼠标在组件内移动事件
大部分 HTML 元素


mouseout
鼠标移出组件时触发
大部分 HTML 元素


mouseover
鼠标移入组件时触发
大部分 HTML 元素


Keypdown
键盘按键被按下
HTML 中所有表单元素


keyup
键盘按键被抬起
HTML 中所有表单元素


事件修饰符
capture修饰符
  可以将监听事件的实际设置为捕获阶段，示例如下：
  &lt;div @click.capture=&quot;click1&quot; style=&quot;border:solid red&quot;&gt;     外层    &lt;div @click.capture=&quot;click2&quot; style=&quot;border:solid red&quot;&gt;        中层        &lt;div @click.capture=&quot;click3&quot; style=&quot;border:solid red&quot;&gt;            点击        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;          
  点击最内层元素，控制台输出：
  外层中层内层

stop修饰符
  stop修饰符可以阻止事件的传递，例如：
  &lt;div @click.stop=&quot;click1&quot; style=&quot;border:solid red&quot;&gt;     外层    &lt;div @click.stop=&quot;click2&quot; style=&quot;border:solid red&quot;&gt;        中层        &lt;div @click.stop=&quot;click3&quot; style=&quot;border:solid red&quot;&gt;            点击        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;
  点击最内层元素，控制台：
  内层

其他修饰符








事件修饰符
作 用


stop
阻止事件传递


capture
监听捕获场景的事件


once
只触发一次事件


exact
只有精确满足按键的条件才会触发事件（按键组合）


self
当事件对象的 target 属性是当前组件时才触发事件


Prevent
禁止默认的事件


passive
不禁止默认事件


其他鼠标按键修饰符



left
鼠标左键（click.left）


right
鼠标右键


middle
鼠标中键



系统按键修饰符
  Vue中还提供了一些特殊的系统按键修饰符，这些修饰符是配合其他键盘按键或鼠标按键进行使用的，主要有如下4种：
  ctrl, shift, alt, meta(windows&#x2F;command)
  示例：
  &lt;div @mousedown. ctrl=&quot;mousedown&quot;&gt;鼠标按下&lt;/div&gt;&lt;--! 上面代码的作用是用户按下Ctrl键的同时,再按下鼠标按键才会触发绑定的事件函数。--&gt;
  &lt;input @keyup.alt.enter=&quot;keyup&quot;&gt;&lt;/input&gt; &lt;--! 上面代码的作用是用户按下Alt键的同时,再按回车键才会触发绑定的事件函数。 --&gt;


v-bind(:)基本用法为html标签绑定属性值（在html标签内，不能使用插值表达式）


]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Join(two tables)</title>
    <url>/2025/06/04/join/</url>
    <content><![CDATA[Basic sentenceSELECT columnsFROM table1() JOIN table2ON table1.column_name=table2.column_name; 

INNER JOININNER JOIN equals to JOIN,
Explicit form 
INNER JOIN

Implicit form
JOIN

Tables :Person :



personID
lastName
firstName



1
Wang
Allen


2
Alice
Bob


Address:



addressID
personID
city
state



1
2
New York City
New York


2
3
Leetcode
California


SELECT Person.firstName, Address.cityFROM PersonINNER JOIN AddressON Person.personID = Address.personID;

result:



firstName
city



Bob
New York City



LEFT JOINTables :SELECT Person.firstName, Address.cityFROM Person LEFT JOIN Address # Write in one line is more intuitiveON Person.personID = Address.personID;

result:



firstName
city



Bob
New York City


Allen
NULL



RIGHT JOINTables :SELECT Person.firstName, Address.cityFROM Person RIGHT JOIN Address # Write in one line is more intuitiveON Person.personID = Address.personID;

result:



firstName
city



Bob
New York City


NULL
Leetcode



FULL JOINTables :SELECT Person.firstName, Address.cityFROM Person FULL JOIN AddressON Person.personID = Address.personID;

result:



firstName
city



Bob
New York City


Allen
NULL


NULL
Leetcode



Summary
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/09/14/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
      <categories>
        <category>Instruction</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mixin技术</title>
    <url>/2025/11/17/mixin/</url>
    <content><![CDATA[基本用法
通过Mixin技术，组件的复用性可以得到进一步的提高：

&lt;body&gt;  &lt;div id=&quot;Application&quot;&gt;    &lt;my-com1 title=&quot;组件1&quot;&gt;&lt;/my-com1&gt;    &lt;my-com2 title=&quot;组件2&quot;&gt;&lt;/my-com2&gt;    &lt;my-com3 title=&quot;组件3&quot;&gt;&lt;/my-com3&gt;  &lt;/div&gt;  &lt;script&gt;    const App = Vue.createApp(&#123;&#125;);    const com1 = &#123;      props: [&#x27;title&#x27;],      template: `        &lt;div style=&quot;border:red solid 2px;&quot;&gt;          &#123;&#123; title &#125;&#125;        &lt;/div&gt;      `    &#125;;    const com2 = &#123;      props: [&#x27;title&#x27;],      template: `        &lt;div style=&quot;border:blue solid 2px;&quot;&gt;          &#123;&#123; title &#125;&#125;        &lt;/div&gt;      `    &#125;;    const com3 = &#123;      props: [&#x27;title&#x27;],      template: `        &lt;div style=&quot;border:green solid 2px;&quot;&gt;          &#123;&#123; title &#125;&#125;        &lt;/div&gt;      `    &#125;;    // 注册组件    App.component(&quot;my-com1&quot;, com1);    App.component(&quot;my-com2&quot;, com2);    App.component(&quot;my-com3&quot;, com3);    // 挂载应用    App.mount(&quot;#Application&quot;);  &lt;/script&gt;&lt;/body&gt;


我们可以定义一个混入对象(Mixin)，混入对象中可以包含任意的组件定义选项，当此对象被混入组件时，组件会将混入对象中提供的选项引入当前组件内部。

&lt;body&gt;  &lt;div id=&quot;Application&quot;&gt;    &lt;my-com1 title=&quot;组件1&quot;&gt;&lt;/my-com1&gt;    &lt;my-com2 title=&quot;组件2&quot;&gt;&lt;/my-com2&gt;    &lt;my-com3 title=&quot;组件3&quot;&gt;&lt;/my-com3&gt;  &lt;/div&gt;  &lt;script&gt;    const App = Vue.createApp(&#123;&#125;);    const myMixin = &#123;        props: [&#x27;title&#x27;]    &#125;    const com1 = &#123;      mixins: [myMixin],      template: `        &lt;div style=&quot;border:red solid 2px;&quot;&gt;          &#123;&#123; title &#125;&#125;        &lt;/div&gt;      `    &#125;;    const com2 = &#123;      mixins: [myMixin],          template: `        &lt;div style=&quot;border:blue solid 2px;&quot;&gt;          &#123;&#123; title &#125;&#125;        &lt;/div&gt;      `    &#125;;    const com3 = &#123;      mixins: [myMixin],      template: `        &lt;div style=&quot;border:green solid 2px;&quot;&gt;          &#123;&#123; title &#125;&#125;        &lt;/div&gt;      `    &#125;;    // 注册组件    App.component(&quot;my-com1&quot;, com1);    App.component(&quot;my-com2&quot;, com2);    App.component(&quot;my-com3&quot;, com3);    // 挂载应用    App.mount(&quot;#Application&quot;);  &lt;/script&gt;&lt;/body&gt;

Mixin选项的合并当混入对象与组件中定义了相同的选项时，Vue可以非常智能地对这些选项进行合并。

不冲突的配置将完整合并：
  混入对象中定义了组件的属性数据，包含a、b和c共3个属性，组件本身定义了d属性，最终组件在使用时，其内部的属性会包含a、b、c和d。


const myMixin = &#123;  data() &#123;    return &#123;      a: &quot;a&quot;,      b: &quot;b&quot;,      c: &quot;c&quot;    &#125;  &#125;&#125;const com = &#123;  mixins: [myMixin],  data() &#123;    return &#123;      d: &quot;d&quot;    &#125;  &#125;,  // 组件被创建后会调用,用来测试混入的数据情况  created() &#123;    // a,b,c,d都存在    console.log(this.$data)  &#125;&#125;


如果属性的定义有冲突，则以组件内部定义的为准，例如:

const myMixin = &#123;  props: [&#x27;title&#x27;],  data() &#123;    return &#123;      a: &#x27;a&#x27;,      b: &#x27;b&#x27;,      c: &#x27;c&#x27;    &#125;  &#125;&#125;const com = &#123;  mixins: [myMixin],  data() &#123;    return &#123;      c: &#x27;C&#x27; // 覆盖 mixin 中的 c    &#125;  &#125;,  created() &#123;    // 组件创建后执行，验证数据合并结果    console.log(this.$data); // 输出：&#123; a: &#x27;a&#x27;, b: &#x27;b&#x27;, c: &#x27;C&#x27; &#125;  &#125;&#125;

全局Mixin
直接对应用实例进行Mixin设置即可：

const App = Vue.createApp(&#123;&#125;)App.mixin(&#123;	mounted()&#123;		console.log(&quot;Mixin对象mounted&quot;)	&#125;&#125;)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>组件的高级配置(应用的全局配置选项)</title>
    <url>/2025/10/20/global-configuration/</url>
    <content><![CDATA[当调用Vue.createApp方法后，会创建一个Vue应用实例，对于此应用实例，其内部封装了一个config对象，我们可以通过这个对象的一些全局选项来对其进行配置。常用的配置项有异常与警告捕获配置和全局属性配置。

异常和警告，使用自定义的函数来对抛出的异常和警告进行处理：
  const App = Vue.createApp(&#123;&#125;)App.config.errorHandler = (err, vm, info) =&gt; &#123;    // 捕获运行中产生的异常    // err参数是错误对象,info为具体的错误信息&#125;App.config.warnHandler = (msg, vm, trace) =&gt; &#123;    // 捕获运行中产生的警告    // msg是警告信息,trace是组件的关系回溯&#125;

通过globalProperties全局属性对象进行配置：
  const App = Vue.createApp(&#123;&#125;)// 配置全局数据App.config.globalProperties = &#123;    version: &quot;1.0.0&quot;&#125;const sub = &#123;    mounted() &#123;        // 在任意组件的任意地方都可以通过this直接访问全局数据        console.log(this.version)    &#125;&#125;

]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Regular Expression</title>
    <url>/2025/06/15/regexp/</url>
    <content><![CDATA[一般形式WHERE example_column REGEXP &#x27;这里写正则表达式内容&#x27;

注意：

要加引号

默认情况不区分大小写
  若要区分，则使用


REGEXP BINARY


基本用法^ 表示字符串开始
e.g.  ^e表示以e开始
注意:若^在[]里面,则表示取补集
e.g.  [^a]表示除了a以外的所有字母

$表示字符串结束
e.g.x$表示以x结束

[]表示 character set，结合-使用表示范围，
e.g: [1-9]表示1,2,3,4,5….8,9组成的集合
[cde]表示c,d,e中的一个字符

{}为数量符,匹配前一个字符的数量
e.g: [0-9]{2}表示2个0-9中的任意字符
e{3,5}表示至少3个,至多5个e

？为数量符，匹配前一个字符1次或0次 
e.g.  -?表示搜寻’0个或者1个字符 “-“ 

+为数量符,匹配前一个字符至少1次
e.g.  3[a-z]+4表示3与4之间有至少一个字母

*为数量符,匹配前一个字符0次或多次(包括1次)
.等价于占位符,匹配(除了换行符外的)单个字符
|表示逻辑运算符”或”

例题电话号码格式校验_牛客题霸_牛客网
【鲸析】SQL面试大实话之【正则表达式 REGEXP 实战解析】_哔哩哔哩_bilibili

总结
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Distinguish having and where</title>
    <url>/2025/06/16/having-where/</url>
    <content><![CDATA[



WHERE
HAVING



执行时机
分组前过滤
分组后过滤


使用对象
原始表中的列
分组结果或聚合函数计算结果


性能
通常更高效
通常效率较低


SELECT department, AVG(salary) FROM employees GROUP BY department HAVING AVG(salary) &gt; 5000;  -- 不能用WHERE过滤聚合结果

SELECT product_id, COUNT(*) as order_countFROM ordersGROUP BY product_idHAVING order_count &gt; 10;  -- 过滤分组后的计数结果

SELECT customer_id, SUM(amount) as total_spentFROM transactionsGROUP BY customer_idHAVING total_spent &gt; 1000;  -- WHERE不能使用别名


使用建议
优先使用WHERE：能在WHERE中完成的条件就不要用HAVING，减少分组处理的数据量
必须时才用HAVING：只有当过滤条件依赖于分组结果或聚合函数时才使用HAVING
组合使用：经常WHERE和HAVING一起使用，先用WHERE初步筛选，再用HAVING对分组结果过滤

]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>组件中数据与事件的传递</title>
    <url>/2025/09/29/transmit/</url>
    <content><![CDATA[基本用法
当我们创建好了Vue应用实例后，使用mount方法可以将其绑定到指定的HTML元素上。应用实例可以使用component方法来定义组件，定义好组件后，可以直接在HTML文档中进行使用。

自定义警告提示框：


&lt;script&gt;  const App = Vue.createApp(&#123;&#125;)    const alertComponent = &#123;    data() &#123;      return &#123;        msg: &quot;警告框提示&quot;,        count: 0      &#125;    &#125;,    methods: &#123;      click() &#123;        alert(this.msg + this.count++)      &#125;    &#125;,    template: `&lt;div&gt;&lt;button @click=&quot;click&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;`  &#125;    App.component(&quot;my-alert&quot;, alertComponent)  App.mount(&quot;#Application&quot;)&lt;/script&gt;

需要使用自定义的组件时，只需使用组件名标签即可：
&lt;div id=&quot;Application&quot;&gt;    &lt;my-alert&gt;&lt;/my-alert&gt;    &lt;my-alert&gt;&lt;/my-alert&gt;&lt;/div&gt;

处理组件事件
用emit传递事件

&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue组件&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-alert @myclick=&quot;appfunc&quot; title=&quot;btn1&quot;&gt;&lt;/my-alert&gt;        &lt;my-alert title=&quot;btn2&quot;&gt;&lt;/my-alert&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123;            methods:&#123;                appfunc()&#123;                    console.log(&quot;btn clicked&quot;)                &#125;            &#125;        &#125;)        const alertComponent = &#123;            props:[&quot;title&quot;],            template:`&lt;div&gt;&lt;button @click=&quot;$emit(&#x27;myclick&#x27;)&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/button&gt;&lt;/div&gt;`        &#125;        App.component(&quot;my-alert&quot;,alertComponent)        App.mount(&quot;#Application&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;


可以同时传递一些参数

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue组件&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-alert @myclick=&quot;appfunc&quot; title=&quot;btn1&quot;&gt;&lt;/my-alert&gt;        &lt;my-alert @myclick=&quot;appfunc&quot; title=&quot;btn2&quot;&gt;&lt;/my-alert&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123;            methods:&#123;                appfunc(param)&#123;                    console.log(param+&quot; clicked&quot;)                &#125;            &#125;        &#125;)        const alertComponent = &#123;            props:[&quot;title&quot;],            template:`&lt;div&gt;&lt;button @click=&quot;$emit(&#x27;myclick&#x27;,title)&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/button&gt;&lt;/div&gt;`        &#125;        App.component(&quot;my-alert&quot;,alertComponent)        App.mount(&quot;#Application&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;


若在传递事件之前，子组件还有一些内部的逻辑需要处理，也可以在子组件中包装一个方法

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue组件&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-alert @myclick=&quot;appfunc&quot; title=&quot;btn1&quot;&gt;&lt;/my-alert&gt;        &lt;my-alert @myclick=&quot;appfunc&quot; title=&quot;btn2&quot;&gt;&lt;/my-alert&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123;            methods:&#123;                appfunc(param)&#123;                    console.log(param+&quot; clicked&quot;)                &#125;            &#125;        &#125;)        const alertComponent = &#123;            props:[&quot;title&quot;],            methods:&#123;                click1()&#123;                    console.log(&quot;inside&quot;)                    this.$emit(&#x27;myclick&#x27;,this.title)                &#125;            &#125;,            template:`&lt;div&gt;&lt;button @click=&quot;click1&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/button&gt;&lt;/div&gt;`        &#125;        App.component(&quot;my-alert&quot;,alertComponent)        App.mount(&quot;#Application&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

在组件上使用v-model指令&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue组件&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-input v-model=&quot;inputText&quot;&gt;&lt;/my-input&gt;        &lt;div&gt;&#123;&#123;inputText&#125;&#125;&lt;/div&gt;        &lt;button @click=&quot;inputText = &#x27;&#x27;&quot;&gt;清空&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123;            data() &#123;                return &#123;                    inputText: &quot;&quot;                &#125;            &#125;        &#125;)        const inputComponent = &#123;            props: [&quot;modelValue&quot;],            methods: &#123;                action(event) &#123;                    this.$emit(&#x27;update:modelValue&#x27;, event.target.value)                &#125;            &#125;,            template: &#x27;&lt;div&gt;&lt;span&gt;输入框:&lt;/span&gt;&lt;input :value=&quot;modelValue&quot; @input=&quot;action&quot;&gt;&lt;/div&gt;&#x27;        &#125;        App.component(&quot;my-input&quot;, inputComponent)        App.mount(&quot;#Application&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

其实，所有支持v-model指令的组件中默认都会提供一个名为modelValue的属性，而**组件内部的内容变化后向外传递的事件为update:modelValue**，并且在事件传递时会将组件内容作为参数进行传递。因此，我们要让自定义组件能够使用v-model指令，只需要按照正确的规范来定义组件即可。
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义组件的插槽</title>
    <url>/2025/10/16/slot/</url>
    <content><![CDATA[插槽是指HTML起始标签与结束标签中间的部分，通常在使用div标签时，其内部的插槽位置既可以放置要显示的文案，又可以嵌套放置其他标签，例如：
&lt;div&gt;文案部分&lt;/div&gt;&lt;div&gt;	&lt;button&gt;按钮&lt;/button&gt;&lt;/div&gt;

插槽的核心作用是将组件内部的元素抽离到外部进行实现，在进行自定义组件的设计时，良好的插槽逻辑可以使组件的使用更加灵活。

基本用法&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue组件插槽&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-container&gt;插槽内部&lt;/my-container&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123; &#125;)        const containerComponent = &#123;            template: `&lt;div style=&quot;border-style:solid;border-color:red; border-width:10px&quot;&gt;                &lt;slot&gt;默认内容&lt;/slot&gt;            &lt;/div&gt;`        &#125;        App.component(&quot;my-container&quot;, containerComponent)        App.mount(&quot;#Application&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;


使用slot标签来指定插槽的位置
可以为插槽添加默认内容（组件在使用时设置了插槽的内容，默认内容就不会被渲染）


(多)具名插槽的用法
若要为插槽设置名称，则可以使用name属性来为其设置名称
需要注意的是，在使用此组件时，要使用template标签来包装插槽内容，对于template标签，通过#（等价于v-slot）来指定与其对应的插槽位置。

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue组件插槽&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;Application&quot;&gt;        &lt;my-container2&gt;            &lt;template #header&gt;                &lt;h1&gt;这里是头部元素&lt;/h1&gt;            &lt;/template&gt;                    &lt;template #main&gt;                &lt;p&gt;内容部分&lt;/p&gt;                &lt;p&gt;内容部分&lt;/p&gt;            &lt;/template&gt;                    &lt;template #footer&gt;                &lt;p&gt;这里是尾部元素&lt;/p&gt;            &lt;/template&gt;        &lt;/my-container2&gt;    &lt;/div&gt;    &lt;script&gt;        const App = Vue.createApp(&#123;        &#125;)        const container2Component = &#123;            template:`&lt;div&gt;                    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;                    &lt;hr/&gt;                    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;                    &lt;hr/&gt;                    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;                &lt;/div&gt;`        &#125;        App.component(&quot;my-container2&quot;, container2Component)        App.mount(&quot;#Application&quot;)     &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Data type</title>
    <url>/2025/06/23/type/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Union</title>
    <url>/2025/06/05/union/</url>
    <content><![CDATA[Basic SentenceSELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2


The SELECT statements within a UNION must have the same number of columns. Columns must also have similar data types. Meanwhile, the order of the columns in each SELECT statement must be the same.
SELECT will automatic deduplication, while SELECT ALL will not.


UNIONTables:
employees:



emp_id
name
dpt_id



1
apple
101


2
boy
102


3
cat
101


4
dog
103


former_employees:



emp_id
name
dpt_id



5
egg
102


2
boy
102


SELECT name, dpt_id FROM employeesUNIONSELECT name, dpt_id FROM former_employees;

result:



name
dpt_id




apple
101



boy
102
automatic deduplication


cat
101



dog
103



egg
102




UNION ALLTables: 
SELECT name, dpt_id FROM employeesUNION ALLSELECT name, dpt_id FROM former_employees;

result:



name
dpt_id




apple
101



boy
102
first record


cat
101



dog
103



egg
102



boy
102
from former_employees


]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
